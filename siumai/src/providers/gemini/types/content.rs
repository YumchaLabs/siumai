use serde::{Deserialize, Serialize};

/// The base structured datatype containing multi-part content of a message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Content {
    /// Optional. The producer of the content. Must be either 'user' or 'model'.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    /// Ordered Parts that constitute a single message.
    pub parts: Vec<Part>,
}

/// A datatype containing media that is part of a multi-part Content message.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Part {
    /// Text content
    Text {
        text: String,
        /// Optional. Whether this is a thought summary (for thinking models)
        #[serde(skip_serializing_if = "Option::is_none")]
        thought: Option<bool>,
    },
    /// Inline data (images, audio, etc.)
    InlineData {
        #[serde(rename = "inlineData")]
        inline_data: Blob,
    },
    /// File data
    FileData {
        #[serde(rename = "fileData")]
        file_data: FileData,
    },
    /// Function call
    FunctionCall {
        #[serde(rename = "functionCall")]
        function_call: FunctionCall,
    },
    /// Function response
    FunctionResponse {
        #[serde(rename = "functionResponse")]
        function_response: FunctionResponse,
    },
    /// Executable code
    ExecutableCode {
        #[serde(rename = "executableCode")]
        executable_code: ExecutableCode,
    },
    /// Code execution result
    CodeExecutionResult {
        #[serde(rename = "codeExecutionResult")]
        code_execution_result: CodeExecutionResult,
    },
}

/// Raw media bytes with MIME type.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Blob {
    pub mime_type: String,
    pub data: String,
}

/// URI based data.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileData {
    pub file_uri: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mime_type: Option<String>,
}

/// A predicted `FunctionCall` returned from the model.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FunctionCall {
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub args: Option<serde_json::Value>,
}

/// The result output from a `FunctionCall`.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FunctionResponse {
    pub name: String,
    pub response: serde_json::Value,
}

/// Code generated by the model that is meant to be executed.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutableCode {
    pub language: CodeLanguage,
    pub code: String,
}

/// Programming language enumeration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CodeLanguage {
    #[serde(rename = "LANGUAGE_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "PYTHON")]
    Python,
}

/// Result of executing the `ExecutableCode`.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CodeExecutionResult {
    pub outcome: CodeExecutionOutcome,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub output: Option<String>,
}

/// Code execution outcome enumeration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CodeExecutionOutcome {
    #[serde(rename = "OUTCOME_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "OUTCOME_OK")]
    Ok,
    #[serde(rename = "OUTCOME_FAILED")]
    Failed,
    #[serde(rename = "OUTCOME_DEADLINE_EXCEEDED")]
    DeadlineExceeded,
}

/// A candidate response generated by the model.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Candidate {
    /// Output only. Generated content returned from the model.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content: Option<Content>,
    /// Optional. Output only. The reason why the model stopped generating tokens.
    #[serde(skip_serializing_if = "Option::is_none", rename = "finishReason")]
    pub finish_reason: Option<FinishReason>,
    /// List of ratings for the safety of a response candidate.
    #[serde(default, rename = "safetyRatings")]
    pub safety_ratings: Vec<SafetyRating>,
    /// Output only. Citation information for model-generated candidate.
    #[serde(skip_serializing_if = "Option::is_none", rename = "citationMetadata")]
    pub citation_metadata: Option<CitationMetadata>,
    /// Output only. Token count for this candidate.
    #[serde(skip_serializing_if = "Option::is_none", rename = "tokenCount")]
    pub token_count: Option<i32>,
    /// Output only. Grounding metadata for the candidate.
    /// Populated for GenerateContent requests when grounding is enabled.
    #[serde(skip_serializing_if = "Option::is_none", rename = "groundingMetadata")]
    pub grounding_metadata: Option<GroundingMetadata>,
    /// Output only. URL context metadata for the candidate.
    /// Populated when URL context tool is used.
    #[serde(skip_serializing_if = "Option::is_none", rename = "urlContextMetadata")]
    pub url_context_metadata: Option<UrlContextMetadata>,
    /// Output only. Index of the candidate in the list of candidates.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index: Option<i32>,
}

/// Defines the reason why the model stopped generating tokens.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FinishReason {
    #[serde(rename = "FINISH_REASON_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "STOP")]
    Stop,
    #[serde(rename = "MAX_TOKENS")]
    MaxTokens,
    #[serde(rename = "SAFETY")]
    Safety,
    #[serde(rename = "RECITATION")]
    Recitation,
    #[serde(rename = "LANGUAGE")]
    Language,
    #[serde(rename = "OTHER")]
    Other,
    #[serde(rename = "BLOCKLIST")]
    Blocklist,
    #[serde(rename = "PROHIBITED_CONTENT")]
    ProhibitedContent,
    #[serde(rename = "SPII")]
    Spii,
    #[serde(rename = "MALFORMED_FUNCTION_CALL")]
    MalformedFunctionCall,
}

/// A collection of source attributions for a piece of content.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CitationMetadata {
    #[serde(default)]
    pub citation_sources: Vec<CitationSource>,
}

/// A citation to a source for a portion of a specific response.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CitationSource {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start_index: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end_index: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub license: Option<String>,
}

/// Safety rating for a piece of content.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SafetyRating {
    pub category: HarmCategory,
    pub probability: HarmProbability,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub blocked: Option<bool>,
}

/// The category of a rating.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum HarmCategory {
    #[serde(rename = "HARM_CATEGORY_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "HARM_CATEGORY_DEROGATORY")]
    Derogatory,
    #[serde(rename = "HARM_CATEGORY_TOXICITY")]
    Toxicity,
    #[serde(rename = "HARM_CATEGORY_VIOLENCE")]
    Violence,
    #[serde(rename = "HARM_CATEGORY_SEXUAL")]
    Sexual,
    #[serde(rename = "HARM_CATEGORY_MEDICAL")]
    Medical,
    #[serde(rename = "HARM_CATEGORY_DANGEROUS")]
    Dangerous,
    #[serde(rename = "HARM_CATEGORY_HARASSMENT")]
    Harassment,
    #[serde(rename = "HARM_CATEGORY_HATE_SPEECH")]
    HateSpeech,
    #[serde(rename = "HARM_CATEGORY_SEXUALLY_EXPLICIT")]
    SexuallyExplicit,
    #[serde(rename = "HARM_CATEGORY_DANGEROUS_CONTENT")]
    DangerousContent,
    #[serde(rename = "HARM_CATEGORY_CIVIC_INTEGRITY")]
    CivicIntegrity,
}

/// The probability that a piece of content is harmful.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum HarmProbability {
    #[serde(rename = "HARM_PROBABILITY_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "NEGLIGIBLE")]
    Negligible,
    #[serde(rename = "LOW")]
    Low,
    #[serde(rename = "MEDIUM")]
    Medium,
    #[serde(rename = "HIGH")]
    High,
}

/// Safety setting, affecting the safety-blocking behavior.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SafetySetting {
    pub category: HarmCategory,
    pub threshold: HarmBlockThreshold,
}

/// Block at and beyond a specified harm probability.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum HarmBlockThreshold {
    #[serde(rename = "HARM_BLOCK_THRESHOLD_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "BLOCK_LOW_AND_ABOVE")]
    BlockLowAndAbove,
    #[serde(rename = "BLOCK_MEDIUM_AND_ABOVE")]
    BlockMediumAndAbove,
    #[serde(rename = "BLOCK_ONLY_HIGH")]
    BlockOnlyHigh,
    #[serde(rename = "BLOCK_NONE")]
    BlockNone,
}

/// Tool details that the model may use to generate response.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GeminiTool {
    FunctionDeclarations {
        function_declarations: Vec<FunctionDeclaration>,
    },
    CodeExecution {
        code_execution: CodeExecution,
    },
    /// Google Search grounding (Gemini 2.0+)
    GoogleSearch {
        google_search: GoogleSearch,
    },
    /// Google Search Retrieval (Legacy, for Gemini 1.5)
    GoogleSearchRetrieval {
        google_search_retrieval: GoogleSearchRetrieval,
    },
    /// URL Context tool
    UrlContext {
        url_context: UrlContext,
    },
}

/// Structured representation of a function declaration.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FunctionDeclaration {
    pub name: String,
    pub description: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parameters: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub response: Option<serde_json::Value>,
}

/// Tool that executes code generated by the model.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CodeExecution {/* empty */}

/// Google Search grounding tool (Gemini 2.0+)
/// Enables the model to ground responses using Google Search
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GoogleSearch {}

/// Google Search Retrieval tool (Legacy, for Gemini 1.5)
/// Provides dynamic retrieval configuration for search grounding
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GoogleSearchRetrieval {
    /// Optional dynamic retrieval configuration
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "dynamicRetrievalConfig"
    )]
    pub dynamic_retrieval_config: Option<DynamicRetrievalConfig>,
}

/// Dynamic retrieval configuration for Google Search Retrieval
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DynamicRetrievalConfig {
    /// Retrieval mode
    pub mode: DynamicRetrievalMode,
    /// Dynamic threshold (0.0 to 1.0)
    /// Only search if confidence > threshold
    #[serde(skip_serializing_if = "Option::is_none", rename = "dynamicThreshold")]
    pub dynamic_threshold: Option<f32>,
}

/// Dynamic retrieval mode
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DynamicRetrievalMode {
    /// Unspecified mode
    #[serde(rename = "MODE_UNSPECIFIED")]
    Unspecified,
    /// Dynamic mode - model decides when to search
    #[serde(rename = "MODE_DYNAMIC")]
    Dynamic,
}

/// URL Context tool
/// Enables the model to retrieve content from specified URLs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UrlContext {}

// File management types

/// Gemini File object
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GeminiFile {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mime_type: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub size_bytes: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub create_time: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub update_time: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expiration_time: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sha256_hash: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub state: Option<GeminiFileState>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<GeminiStatus>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub video_metadata: Option<VideoFileMetadata>,
}

/// Processing state of the File
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum GeminiFileState {
    #[serde(rename = "STATE_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "PROCESSING")]
    Processing,
    #[serde(rename = "ACTIVE")]
    Active,
    #[serde(rename = "FAILED")]
    Failed,
}

/// Error status for file processing
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GeminiStatus {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub details: Option<Vec<serde_json::Value>>,
}

/// Metadata for a video file
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VideoFileMetadata {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub video_duration: Option<String>,
}

/// Request for `CreateFile`
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateFileRequest {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file: Option<GeminiFile>,
}

/// Response for `CreateFile`
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateFileResponse {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file: Option<GeminiFile>,
}

/// Response for `ListFiles`
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ListFilesResponse {
    #[serde(default)]
    pub files: Vec<GeminiFile>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_page_token: Option<String>,
}

/// Response for `DownloadFile`
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DownloadFileResponse {}

// Convenience constructors
impl Content {
    /// Create user content with text
    pub fn user_text(text: String) -> Self {
        Self {
            role: Some("user".to_string()),
            parts: vec![Part::text(text)],
        }
    }
    /// Create model content with text
    pub fn model_text(text: String) -> Self {
        Self {
            role: Some("model".to_string()),
            parts: vec![Part::text(text)],
        }
    }
    /// Create system content with text
    pub fn system_text(text: String) -> Self {
        Self {
            role: None,
            parts: vec![Part::text(text)],
        }
    }
}

impl Part {
    /// Create a text part
    pub const fn text(text: String) -> Self {
        Self::Text {
            text,
            thought: None,
        }
    }
    /// Create a thought summary part
    pub const fn thought_summary(text: String) -> Self {
        Self::Text {
            text,
            thought: Some(true),
        }
    }
    /// Create an inline data part
    pub const fn inline_data(mime_type: String, data: String) -> Self {
        Self::InlineData {
            inline_data: Blob { mime_type, data },
        }
    }
    /// Create a file data part
    pub const fn file_data(file_uri: String, mime_type: Option<String>) -> Self {
        Self::FileData {
            file_data: FileData {
                file_uri,
                mime_type,
            },
        }
    }
    /// Create a function call part
    pub const fn function_call(name: String, args: Option<serde_json::Value>) -> Self {
        Self::FunctionCall {
            function_call: FunctionCall { name, args },
        }
    }
    /// Create a function response part
    pub const fn function_response(name: String, response: serde_json::Value) -> Self {
        Self::FunctionResponse {
            function_response: FunctionResponse { name, response },
        }
    }
}

// Grounding metadata types

/// Grounding metadata returned when grounding is enabled
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GroundingMetadata {
    /// List of supporting references retrieved from the specified grounding source
    #[serde(skip_serializing_if = "Option::is_none", rename = "groundingChunks")]
    pub grounding_chunks: Option<Vec<GroundingChunk>>,
    /// List of grounding support
    #[serde(skip_serializing_if = "Option::is_none", rename = "groundingSupports")]
    pub grounding_supports: Option<Vec<GroundingSupport>>,
    /// Web search queries for follow-up web searches
    #[serde(skip_serializing_if = "Option::is_none", rename = "webSearchQueries")]
    pub web_search_queries: Option<Vec<String>>,
    /// Optional. Google Search entry point for follow-up web searches
    #[serde(skip_serializing_if = "Option::is_none", rename = "searchEntryPoint")]
    pub search_entry_point: Option<SearchEntryPoint>,
    /// Metadata related to retrieval in the grounding flow
    #[serde(skip_serializing_if = "Option::is_none", rename = "retrievalMetadata")]
    pub retrieval_metadata: Option<RetrievalMetadata>,
    /// Optional. Google Maps widget context token
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "googleMapsWidgetContextToken"
    )]
    pub google_maps_widget_context_token: Option<String>,
}

/// A grounding chunk
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroundingChunk {
    /// Grounding chunk from the web
    Web { web: WebGroundingChunk },
    /// Grounding chunk from retrieved context
    RetrievedContext {
        #[serde(rename = "retrievedContext")]
        retrieved_context: RetrievedContextChunk,
    },
}

/// Grounding chunk from the web
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WebGroundingChunk {
    /// URI reference for the chunk
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    /// Title of the chunk
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
}

/// Grounding chunk from retrieved context
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RetrievedContextChunk {
    /// Optional. URI of the document for semantic retrieval
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    /// Optional. Title of the document
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    /// Optional. Text of the chunk
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
}

/// Grounding support
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GroundingSupport {
    /// List of indices (into grounding_chunk) specifying the citations associated with the claim
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "groundingChunkIndices"
    )]
    pub grounding_chunk_indices: Option<Vec<i32>>,
    /// Confidence scores of the support references
    #[serde(skip_serializing_if = "Option::is_none", rename = "confidenceScores")]
    pub confidence_scores: Option<Vec<f32>>,
}

/// Google Search entry point
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchEntryPoint {
    /// Optional. Web content snippet that can be embedded in a web page or an app webview
    #[serde(skip_serializing_if = "Option::is_none", rename = "renderedContent")]
    pub rendered_content: Option<String>,
    /// Optional. Base64 encoded JSON representing array of <search term, search URL> tuple
    #[serde(skip_serializing_if = "Option::is_none", rename = "sdkBlob")]
    pub sdk_blob: Option<String>,
}

/// Metadata related to retrieval in the grounding flow
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RetrievalMetadata {
    /// Optional. Score indicating how likely information from Google Search would help in answering the prompt
    #[serde(
        skip_serializing_if = "Option::is_none",
        rename = "googleSearchDynamicRetrievalScore"
    )]
    pub google_search_dynamic_retrieval_score: Option<f32>,
}

/// URL context metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UrlContextMetadata {
    /// List of URL contexts
    #[serde(skip_serializing_if = "Option::is_none", rename = "urlMetadata")]
    pub url_metadata: Option<Vec<UrlMetadata>>,
}

/// Single URL retrieval context
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UrlMetadata {
    /// URL retrieved by the tool
    #[serde(skip_serializing_if = "Option::is_none", rename = "retrievedUrl")]
    pub retrieved_url: Option<String>,
    /// URL retrieval status
    #[serde(skip_serializing_if = "Option::is_none", rename = "urlRetrievalStatus")]
    pub url_retrieval_status: Option<UrlRetrievalStatus>,
}

/// URL retrieval status
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum UrlRetrievalStatus {
    /// Default value. This value is unused.
    #[serde(rename = "URL_RETRIEVAL_STATUS_UNSPECIFIED")]
    Unspecified,
    /// URL was successfully retrieved.
    #[serde(rename = "URL_RETRIEVAL_STATUS_SUCCESS")]
    Success,
    /// URL could not be retrieved due to an error.
    #[serde(rename = "URL_RETRIEVAL_STATUS_ERROR")]
    Error,
    /// URL could not be retrieved because the content is paywalled.
    #[serde(rename = "URL_RETRIEVAL_STATUS_PAYWALL")]
    Paywall,
    /// URL could not be retrieved because the content is unsafe.
    #[serde(rename = "URL_RETRIEVAL_STATUS_UNSAFE")]
    Unsafe,
}
