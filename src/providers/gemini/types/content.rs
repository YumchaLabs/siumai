use serde::{Deserialize, Serialize};

/// The base structured datatype containing multi-part content of a message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Content {
    /// Optional. The producer of the content. Must be either 'user' or 'model'.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    /// Ordered Parts that constitute a single message.
    pub parts: Vec<Part>,
}

/// A datatype containing media that is part of a multi-part Content message.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Part {
    /// Text content
    Text {
        text: String,
        /// Optional. Whether this is a thought summary (for thinking models)
        #[serde(skip_serializing_if = "Option::is_none")]
        thought: Option<bool>,
    },
    /// Inline data (images, audio, etc.)
    InlineData {
        #[serde(rename = "inlineData")]
        inline_data: Blob,
    },
    /// File data
    FileData {
        #[serde(rename = "fileData")]
        file_data: FileData,
    },
    /// Function call
    FunctionCall {
        #[serde(rename = "functionCall")]
        function_call: FunctionCall,
    },
    /// Function response
    FunctionResponse {
        #[serde(rename = "functionResponse")]
        function_response: FunctionResponse,
    },
    /// Executable code
    ExecutableCode {
        #[serde(rename = "executableCode")]
        executable_code: ExecutableCode,
    },
    /// Code execution result
    CodeExecutionResult {
        #[serde(rename = "codeExecutionResult")]
        code_execution_result: CodeExecutionResult,
    },
}

/// Raw media bytes with MIME type.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Blob {
    pub mime_type: String,
    pub data: String,
}

/// URI based data.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileData {
    pub file_uri: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mime_type: Option<String>,
}

/// A predicted `FunctionCall` returned from the model.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FunctionCall {
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub args: Option<serde_json::Value>,
}

/// The result output from a `FunctionCall`.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FunctionResponse {
    pub name: String,
    pub response: serde_json::Value,
}

/// Code generated by the model that is meant to be executed.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutableCode {
    pub language: CodeLanguage,
    pub code: String,
}

/// Programming language enumeration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CodeLanguage {
    #[serde(rename = "LANGUAGE_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "PYTHON")]
    Python,
}

/// Result of executing the `ExecutableCode`.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CodeExecutionResult {
    pub outcome: CodeExecutionOutcome,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub output: Option<String>,
}

/// Code execution outcome enumeration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CodeExecutionOutcome {
    #[serde(rename = "OUTCOME_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "OUTCOME_OK")]
    Ok,
    #[serde(rename = "OUTCOME_FAILED")]
    Failed,
    #[serde(rename = "OUTCOME_DEADLINE_EXCEEDED")]
    DeadlineExceeded,
}

/// A candidate response generated by the model.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Candidate {
    /// Output only. Generated content returned from the model.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content: Option<Content>,
    /// Optional. Output only. The reason why the model stopped generating tokens.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub finish_reason: Option<FinishReason>,
    /// List of ratings for the safety of a response candidate.
    #[serde(default)]
    pub safety_ratings: Vec<SafetyRating>,
    /// Output only. Citation information for model-generated candidate.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub citation_metadata: Option<CitationMetadata>,
    /// Output only. Token count for this candidate.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub token_count: Option<i32>,
    /// Output only. Index of the candidate in the list of candidates.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index: Option<i32>,
}

/// Defines the reason why the model stopped generating tokens.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FinishReason {
    #[serde(rename = "FINISH_REASON_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "STOP")]
    Stop,
    #[serde(rename = "MAX_TOKENS")]
    MaxTokens,
    #[serde(rename = "SAFETY")]
    Safety,
    #[serde(rename = "RECITATION")]
    Recitation,
    #[serde(rename = "LANGUAGE")]
    Language,
    #[serde(rename = "OTHER")]
    Other,
    #[serde(rename = "BLOCKLIST")]
    Blocklist,
    #[serde(rename = "PROHIBITED_CONTENT")]
    ProhibitedContent,
    #[serde(rename = "SPII")]
    Spii,
    #[serde(rename = "MALFORMED_FUNCTION_CALL")]
    MalformedFunctionCall,
}

/// A collection of source attributions for a piece of content.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CitationMetadata {
    #[serde(default)]
    pub citation_sources: Vec<CitationSource>,
}

/// A citation to a source for a portion of a specific response.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CitationSource {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start_index: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end_index: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub license: Option<String>,
}

/// Safety rating for a piece of content.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SafetyRating {
    pub category: HarmCategory,
    pub probability: HarmProbability,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub blocked: Option<bool>,
}

/// The category of a rating.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum HarmCategory {
    #[serde(rename = "HARM_CATEGORY_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "HARM_CATEGORY_DEROGATORY")]
    Derogatory,
    #[serde(rename = "HARM_CATEGORY_TOXICITY")]
    Toxicity,
    #[serde(rename = "HARM_CATEGORY_VIOLENCE")]
    Violence,
    #[serde(rename = "HARM_CATEGORY_SEXUAL")]
    Sexual,
    #[serde(rename = "HARM_CATEGORY_MEDICAL")]
    Medical,
    #[serde(rename = "HARM_CATEGORY_DANGEROUS")]
    Dangerous,
    #[serde(rename = "HARM_CATEGORY_HARASSMENT")]
    Harassment,
    #[serde(rename = "HARM_CATEGORY_HATE_SPEECH")]
    HateSpeech,
    #[serde(rename = "HARM_CATEGORY_SEXUALLY_EXPLICIT")]
    SexuallyExplicit,
    #[serde(rename = "HARM_CATEGORY_DANGEROUS_CONTENT")]
    DangerousContent,
    #[serde(rename = "HARM_CATEGORY_CIVIC_INTEGRITY")]
    CivicIntegrity,
}

/// The probability that a piece of content is harmful.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum HarmProbability {
    #[serde(rename = "HARM_PROBABILITY_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "NEGLIGIBLE")]
    Negligible,
    #[serde(rename = "LOW")]
    Low,
    #[serde(rename = "MEDIUM")]
    Medium,
    #[serde(rename = "HIGH")]
    High,
}

/// Safety setting, affecting the safety-blocking behavior.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SafetySetting {
    pub category: HarmCategory,
    pub threshold: HarmBlockThreshold,
}

/// Block at and beyond a specified harm probability.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum HarmBlockThreshold {
    #[serde(rename = "HARM_BLOCK_THRESHOLD_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "BLOCK_LOW_AND_ABOVE")]
    BlockLowAndAbove,
    #[serde(rename = "BLOCK_MEDIUM_AND_ABOVE")]
    BlockMediumAndAbove,
    #[serde(rename = "BLOCK_ONLY_HIGH")]
    BlockOnlyHigh,
    #[serde(rename = "BLOCK_NONE")]
    BlockNone,
}

/// Tool details that the model may use to generate response.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GeminiTool {
    FunctionDeclarations {
        function_declarations: Vec<FunctionDeclaration>,
    },
    CodeExecution {
        code_execution: CodeExecution,
    },
}

/// Structured representation of a function declaration.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FunctionDeclaration {
    pub name: String,
    pub description: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parameters: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub response: Option<serde_json::Value>,
}

/// Tool that executes code generated by the model.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CodeExecution {/* empty */}

// File management types

/// Gemini File object
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GeminiFile {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mime_type: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub size_bytes: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub create_time: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub update_time: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expiration_time: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sha256_hash: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub state: Option<GeminiFileState>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<GeminiStatus>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub video_metadata: Option<VideoFileMetadata>,
}

/// Processing state of the File
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum GeminiFileState {
    #[serde(rename = "STATE_UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "PROCESSING")]
    Processing,
    #[serde(rename = "ACTIVE")]
    Active,
    #[serde(rename = "FAILED")]
    Failed,
}

/// Error status for file processing
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GeminiStatus {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub details: Option<Vec<serde_json::Value>>,
}

/// Metadata for a video file
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VideoFileMetadata {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub video_duration: Option<String>,
}

/// Request for `CreateFile`
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateFileRequest {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file: Option<GeminiFile>,
}

/// Response for `CreateFile`
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateFileResponse {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file: Option<GeminiFile>,
}

/// Response for `ListFiles`
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ListFilesResponse {
    #[serde(default)]
    pub files: Vec<GeminiFile>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_page_token: Option<String>,
}

/// Response for `DownloadFile`
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DownloadFileResponse {}

// Convenience constructors
impl Content {
    /// Create user content with text
    pub fn user_text(text: String) -> Self {
        Self {
            role: Some("user".to_string()),
            parts: vec![Part::text(text)],
        }
    }
    /// Create model content with text
    pub fn model_text(text: String) -> Self {
        Self {
            role: Some("model".to_string()),
            parts: vec![Part::text(text)],
        }
    }
    /// Create system content with text
    pub fn system_text(text: String) -> Self {
        Self {
            role: None,
            parts: vec![Part::text(text)],
        }
    }
}

impl Part {
    /// Create a text part
    pub const fn text(text: String) -> Self {
        Self::Text {
            text,
            thought: None,
        }
    }
    /// Create a thought summary part
    pub const fn thought_summary(text: String) -> Self {
        Self::Text {
            text,
            thought: Some(true),
        }
    }
    /// Create an inline data part
    pub const fn inline_data(mime_type: String, data: String) -> Self {
        Self::InlineData {
            inline_data: Blob { mime_type, data },
        }
    }
    /// Create a file data part
    pub const fn file_data(file_uri: String, mime_type: Option<String>) -> Self {
        Self::FileData {
            file_data: FileData {
                file_uri,
                mime_type,
            },
        }
    }
    /// Create a function call part
    pub const fn function_call(name: String, args: Option<serde_json::Value>) -> Self {
        Self::FunctionCall {
            function_call: FunctionCall { name, args },
        }
    }
    /// Create a function response part
    pub const fn function_response(name: String, response: serde_json::Value) -> Self {
        Self::FunctionResponse {
            function_response: FunctionResponse { name, response },
        }
    }
}
