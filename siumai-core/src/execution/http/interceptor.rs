//! HTTP Interceptor interfaces
//!
//! This module defines a small, ergonomic interceptor API inspired by
//! middleware patterns in HTTP clients. Interceptors can observe and tweak
//! request builders before send, observe responses, be notified of errors, and
//! receive streaming SSE events. The hooks are best-effort and should avoid
//! expensive work by default.

use crate::error::LlmError;
use reqwest::header::HeaderMap;
use std::hash::{Hash, Hasher};

/// Context passed to interceptors describing the request.
#[derive(Clone, Debug)]
pub struct HttpRequestContext {
    /// A stable identifier for correlating logs/metrics across retries and stream events.
    ///
    /// This value is generated by the executor layer and is also injected into
    /// outbound headers by tracing interceptors (e.g., `x-siumai-request-id`).
    pub request_id: String,
    pub provider_id: String,
    pub url: String,
    pub stream: bool,
}

pub fn generate_request_id() -> String {
    uuid::Uuid::new_v4().to_string()
}

/// HTTP interceptor trait
pub trait HttpInterceptor: Send + Sync {
    /// Called before sending a request. Interceptors may add headers or modify
    /// attributes on the request builder. Return the (possibly modified)
    /// builder or an error to short-circuit the request.
    fn on_before_send(
        &self,
        _ctx: &HttpRequestContext,
        builder: reqwest::RequestBuilder,
        _body: &serde_json::Value,
        _headers: &HeaderMap,
    ) -> Result<reqwest::RequestBuilder, LlmError> {
        Ok(builder)
    }

    /// Called after a response is received (only for successful responses).
    fn on_response(
        &self,
        _ctx: &HttpRequestContext,
        _response: &reqwest::Response,
    ) -> Result<(), LlmError> {
        Ok(())
    }

    /// Called when an error occurs during sending or classification.
    fn on_error(&self, _ctx: &HttpRequestContext, _error: &LlmError) {}

    /// Called before retrying a request.
    ///
    /// This is called when a request is about to be retried after an error.
    /// Useful for logging, metrics, or implementing custom retry logic.
    ///
    /// # Arguments
    /// * `ctx` - Request context
    /// * `error` - The error that triggered the retry
    /// * `attempt` - The retry attempt number (1-based, so 1 means first retry)
    fn on_retry(&self, _ctx: &HttpRequestContext, _error: &LlmError, _attempt: usize) {}

    /// Called when an SSE event is received in a streaming request.
    fn on_sse_event(
        &self,
        _ctx: &HttpRequestContext,
        _event: &eventsource_stream::Event,
    ) -> Result<(), LlmError> {
        Ok(())
    }
}

/// A simple logging interceptor backed by `tracing` (no sensitive data).
#[derive(Clone, Default)]
pub struct LoggingInterceptor;

impl HttpInterceptor for LoggingInterceptor {
    fn on_before_send(
        &self,
        ctx: &HttpRequestContext,
        builder: reqwest::RequestBuilder,
        _body: &serde_json::Value,
        _headers: &HeaderMap,
    ) -> Result<reqwest::RequestBuilder, LlmError> {
        tracing::debug!(target: "siumai::http", request_id=%ctx.request_id, provider=%ctx.provider_id, url=%ctx.url, stream=%ctx.stream, "sending request");
        Ok(builder)
    }

    fn on_response(
        &self,
        ctx: &HttpRequestContext,
        response: &reqwest::Response,
    ) -> Result<(), LlmError> {
        tracing::debug!(target: "siumai::http", request_id=%ctx.request_id, provider=%ctx.provider_id, url=%ctx.url, status=%response.status().as_u16(), "response received");
        Ok(())
    }

    fn on_error(&self, ctx: &HttpRequestContext, error: &LlmError) {
        tracing::debug!(target: "siumai::http", request_id=%ctx.request_id, provider=%ctx.provider_id, url=%ctx.url, stream=%ctx.stream, err=%error, "request error");
    }

    fn on_retry(&self, ctx: &HttpRequestContext, error: &LlmError, attempt: usize) {
        tracing::debug!(target: "siumai::http", request_id=%ctx.request_id, provider=%ctx.provider_id, url=%ctx.url, stream=%ctx.stream, err=%error, attempt=%attempt, "retrying request");
    }

    fn on_sse_event(
        &self,
        ctx: &HttpRequestContext,
        event: &eventsource_stream::Event,
    ) -> Result<(), LlmError> {
        tracing::trace!(target: "siumai::http", provider=%ctx.provider_id, url=%ctx.url, event_name=%event.event, "sse event");
        Ok(())
    }
}

/// A structured HTTP tracing interceptor driven by `TracingConfig`.
///
/// This interceptor is designed to replace scattered, provider-specific tracing
/// helpers by leveraging the unified HTTP execution pipeline. It logs:
/// - request start (info)
/// - request headers + JSON body (debug, optional)
/// - response status + headers (debug)
/// - errors and retries
///
/// Notes:
/// - Response bodies are not available via `HttpInterceptor::on_response` because
///   the common executors parse bodies after the hook. For deeper body-level
///   tracing, prefer higher-level transformers/events in `observability::tracing`.
#[derive(Clone)]
pub struct HttpTracingInterceptor {
    config: crate::observability::tracing::TracingConfig,
    state: std::sync::Arc<HttpTracingState>,
}

impl HttpTracingInterceptor {
    pub fn new(config: crate::observability::tracing::TracingConfig) -> Self {
        // Keep legacy formatting helpers consistent.
        crate::observability::tracing::set_pretty_json(config.pretty_json);
        crate::observability::tracing::set_mask_sensitive_values(config.mask_sensitive_values);
        Self {
            config,
            state: std::sync::Arc::new(HttpTracingState::default()),
        }
    }

    fn enabled(&self) -> bool {
        self.config.enable_http_tracing && self.config.sampling_rate > 0.0
    }

    fn should_sample(&self, ctx: &HttpRequestContext) -> bool {
        if !self.enabled() {
            return false;
        }
        if self.config.sampling_rate >= 1.0 {
            return true;
        }
        let mut hasher = std::collections::hash_map::DefaultHasher::new();
        ctx.request_id.hash(&mut hasher);
        let v = hasher.finish() as f64 / u64::MAX as f64;
        v < self.config.sampling_rate
    }

    fn is_sensitive_header_name(name: &str) -> bool {
        let lower = name.to_lowercase();
        lower.contains("authorization") || lower.contains("key") || lower.contains("token")
    }

    fn format_headers(&self, headers: &HeaderMap) -> String {
        let map: std::collections::HashMap<&str, String> = headers
            .iter()
            .filter_map(|(k, v)| {
                let name = k.as_str();
                if !self.config.include_sensitive_headers && Self::is_sensitive_header_name(name) {
                    return None;
                }
                let value = v.to_str().unwrap_or("<invalid>");
                let masked = if Self::is_sensitive_header_name(name) {
                    crate::observability::tracing::mask_sensitive_value(value)
                } else {
                    value.to_string()
                };
                Some((name, masked))
            })
            .collect();

        if crate::observability::tracing::get_pretty_json() {
            serde_json::to_string_pretty(&map).unwrap_or_else(|_| format!("{map:?}"))
        } else {
            serde_json::to_string(&map).unwrap_or_else(|_| format!("{map:?}"))
        }
    }

    fn format_body(&self, body: &serde_json::Value) -> Option<String> {
        if !self.config.include_bodies || self.config.max_body_size == 0 {
            return None;
        }
        let mut s = crate::observability::tracing::format_json_for_logging(body);
        if s.len() > self.config.max_body_size {
            s.truncate(self.config.max_body_size);
            s.push_str("â€¦(truncated)");
        }
        Some(s)
    }
}

impl HttpInterceptor for HttpTracingInterceptor {
    fn on_before_send(
        &self,
        ctx: &HttpRequestContext,
        builder: reqwest::RequestBuilder,
        body: &serde_json::Value,
        headers: &HeaderMap,
    ) -> Result<reqwest::RequestBuilder, LlmError> {
        if !self.should_sample(ctx) {
            return Ok(builder);
        }

        self.state
            .start_times
            .lock()
            .expect("http tracing state poisoned")
            .entry(ctx.request_id.clone())
            .or_insert_with(std::time::Instant::now);

        // Inject request id for correlation (safe, no secrets).
        let builder = builder.header("x-siumai-request-id", ctx.request_id.clone());

        tracing::info!(
            target: "siumai::http",
            request_id = %ctx.request_id,
            provider = %ctx.provider_id,
            url = %ctx.url,
            stream = %ctx.stream,
            "request started"
        );

        let request_headers = self.format_headers(headers);
        if let Some(body_str) = self.format_body(body) {
            tracing::debug!(
                target: "siumai::http",
                request_id = %ctx.request_id,
                provider = %ctx.provider_id,
                url = %ctx.url,
                request_headers = %request_headers,
                request_body = %body_str,
                "request details"
            );
        } else {
            tracing::debug!(
                target: "siumai::http",
                request_id = %ctx.request_id,
                provider = %ctx.provider_id,
                url = %ctx.url,
                request_headers = %request_headers,
                "request headers"
            );
        }

        Ok(builder)
    }

    fn on_response(
        &self,
        ctx: &HttpRequestContext,
        response: &reqwest::Response,
    ) -> Result<(), LlmError> {
        if !self.should_sample(ctx) {
            return Ok(());
        }
        let response_headers = self.format_headers(response.headers());
        let duration_ms = self
            .state
            .start_times
            .lock()
            .expect("http tracing state poisoned")
            .get(&ctx.request_id)
            .map(|t| t.elapsed().as_millis() as u64);
        let retries = self
            .state
            .retry_attempts
            .lock()
            .expect("http tracing state poisoned")
            .get(&ctx.request_id)
            .copied()
            .unwrap_or(0);

        tracing::debug!(
            target: "siumai::http",
            request_id = %ctx.request_id,
            provider = %ctx.provider_id,
            url = %ctx.url,
            status = %response.status().as_u16(),
            duration_ms = duration_ms,
            retries = retries,
            response_headers = %response_headers,
            "response received"
        );

        // Non-streaming requests are finished here; streaming requests will be finalized
        // when we observe the stream-end marker via `on_sse_event`.
        if !ctx.stream {
            self.state.cleanup(&ctx.request_id);
        }
        Ok(())
    }

    fn on_error(&self, ctx: &HttpRequestContext, error: &LlmError) {
        if !self.should_sample(ctx) {
            return;
        }
        let duration_ms = self
            .state
            .start_times
            .lock()
            .expect("http tracing state poisoned")
            .remove(&ctx.request_id)
            .map(|t| t.elapsed().as_millis() as u64);
        let retries = self
            .state
            .retry_attempts
            .lock()
            .expect("http tracing state poisoned")
            .remove(&ctx.request_id)
            .unwrap_or(0);
        let sse_events = self.state.take_stream_events(&ctx.request_id);

        tracing::error!(
            target: "siumai::http",
            request_id = %ctx.request_id,
            provider = %ctx.provider_id,
            url = %ctx.url,
            stream = %ctx.stream,
            err = %error,
            duration_ms = duration_ms,
            retries = retries,
            sse_events = sse_events,
            "request failed"
        );
    }

    fn on_retry(&self, ctx: &HttpRequestContext, error: &LlmError, attempt: usize) {
        if !self.should_sample(ctx) {
            return;
        }
        self.state
            .retry_attempts
            .lock()
            .expect("http tracing state poisoned")
            .entry(ctx.request_id.clone())
            .and_modify(|v| *v = (*v).max(attempt))
            .or_insert(attempt);
        tracing::debug!(
            target: "siumai::http",
            request_id = %ctx.request_id,
            provider = %ctx.provider_id,
            url = %ctx.url,
            stream = %ctx.stream,
            err = %error,
            attempt = %attempt,
            "retrying request"
        );
    }

    fn on_sse_event(
        &self,
        ctx: &HttpRequestContext,
        event: &eventsource_stream::Event,
    ) -> Result<(), LlmError> {
        if !self.should_sample(ctx) || !self.config.enable_stream_tracing {
            return Ok(());
        }

        // Count events without logging each one (avoid log explosion).
        self.state.inc_stream_events(&ctx.request_id);

        // Finalize on stream-end marker.
        if event.data.trim() == "[DONE]" || event.event == "siumai_stream_end" {
            let duration_ms = self
                .state
                .start_times
                .lock()
                .expect("http tracing state poisoned")
                .remove(&ctx.request_id)
                .map(|t| t.elapsed().as_millis() as u64);
            let retries = self
                .state
                .retry_attempts
                .lock()
                .expect("http tracing state poisoned")
                .remove(&ctx.request_id)
                .unwrap_or(0);
            let sse_events = self.state.take_stream_events(&ctx.request_id);
            tracing::info!(
                target: "siumai::http",
                request_id = %ctx.request_id,
                provider = %ctx.provider_id,
                url = %ctx.url,
                duration_ms = duration_ms,
                retries = retries,
                sse_events = sse_events,
                "stream completed"
            );
        }
        Ok(())
    }
}

#[derive(Default)]
struct HttpTracingState {
    start_times: std::sync::Mutex<std::collections::HashMap<String, std::time::Instant>>,
    retry_attempts: std::sync::Mutex<std::collections::HashMap<String, usize>>,
    stream_events: std::sync::Mutex<
        std::collections::HashMap<String, std::sync::Arc<std::sync::atomic::AtomicUsize>>,
    >,
}

impl HttpTracingState {
    fn inc_stream_events(&self, request_id: &str) {
        let counter = {
            let mut map = self
                .stream_events
                .lock()
                .expect("http tracing state poisoned");
            map.entry(request_id.to_string())
                .or_insert_with(|| std::sync::Arc::new(std::sync::atomic::AtomicUsize::new(0)))
                .clone()
        };
        counter.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
    }

    fn take_stream_events(&self, request_id: &str) -> usize {
        self.stream_events
            .lock()
            .expect("http tracing state poisoned")
            .remove(request_id)
            .map(|c| c.load(std::sync::atomic::Ordering::Relaxed))
            .unwrap_or(0)
    }

    fn cleanup(&self, request_id: &str) {
        let _ = self
            .start_times
            .lock()
            .expect("http tracing state poisoned")
            .remove(request_id);
        let _ = self
            .retry_attempts
            .lock()
            .expect("http tracing state poisoned")
            .remove(request_id);
        let _ = self
            .stream_events
            .lock()
            .expect("http tracing state poisoned")
            .remove(request_id);
    }
}
